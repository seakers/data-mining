#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        pass

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def runAutomatedLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def runAutomatedLocalSearchDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def computeComplexityOfFeatures(self, problem, expressions):
        """
        Parameters:
         - problem
         - expressions
        """
        pass

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        pass

    def computeComplexity(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        pass

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        pass

    def getDrivingFeaturesWithGeneralizationBinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def runInputGeneralizationLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
        """
        pass

    def runFeatureGeneralizationLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
        """
        pass

    def setAssigningProblemParameters(self, problem, params):
        """
        Parameters:
         - problem
         - params
        """
        pass

    def getAssigningProblemParameters(self, problem):
        """
        Parameters:
         - problem
        """
        pass

    def setPartitioningAndAssigningProblemParameters(self, problem, params):
        """
        Parameters:
         - problem
         - params
        """
        pass

    def getPartitioningAndAssigningProblemParameters(self, problem):
        """
        Parameters:
         - problem
        """
        pass

    def getTaxonomicScheme(self, problem):
        """
        Parameters:
         - problem
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesBinary()

    def send_getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesBinary failed: unknown result")

    def runAutomatedLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_runAutomatedLocalSearchBinary(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_runAutomatedLocalSearchBinary()

    def send_runAutomatedLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('runAutomatedLocalSearchBinary', TMessageType.CALL, self._seqid)
        args = runAutomatedLocalSearchBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runAutomatedLocalSearchBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runAutomatedLocalSearchBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runAutomatedLocalSearchBinary failed: unknown result")

    def getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        self.send_getMarginalDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift)
        return self.recv_getMarginalDrivingFeaturesBinary()

    def send_getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesBinary failed: unknown result")

    def getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEABinary(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEABinary()

    def send_getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEABinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEABinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEABinary failed: unknown result")

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesDiscrete()

    def send_getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesDiscrete failed: unknown result")

    def runAutomatedLocalSearchDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_runAutomatedLocalSearchDiscrete(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_runAutomatedLocalSearchDiscrete()

    def send_runAutomatedLocalSearchDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('runAutomatedLocalSearchDiscrete', TMessageType.CALL, self._seqid)
        args = runAutomatedLocalSearchDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runAutomatedLocalSearchDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runAutomatedLocalSearchDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runAutomatedLocalSearchDiscrete failed: unknown result")

    def getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        self.send_getMarginalDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift)
        return self.recv_getMarginalDrivingFeaturesDiscrete()

    def send_getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesDiscrete failed: unknown result")

    def getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEADiscrete(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEADiscrete()

    def send_getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEADiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEADiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEADiscrete failed: unknown result")

    def computeComplexityOfFeatures(self, problem, expressions):
        """
        Parameters:
         - problem
         - expressions
        """
        self.send_computeComplexityOfFeatures(problem, expressions)
        return self.recv_computeComplexityOfFeatures()

    def send_computeComplexityOfFeatures(self, problem, expressions):
        self._oprot.writeMessageBegin('computeComplexityOfFeatures', TMessageType.CALL, self._seqid)
        args = computeComplexityOfFeatures_args()
        args.problem = problem
        args.expressions = expressions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexityOfFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexityOfFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexityOfFeatures failed: unknown result")

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        self.send_computeAlgebraicTypicality(problem, arch, feature)
        return self.recv_computeAlgebraicTypicality()

    def send_computeAlgebraicTypicality(self, problem, arch, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicality', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicality_args()
        args.problem = problem
        args.arch = arch
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicality(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicality_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicality failed: unknown result")

    def computeComplexity(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        self.send_computeComplexity(problem, expression)
        return self.recv_computeComplexity()

    def send_computeComplexity(self, problem, expression):
        self._oprot.writeMessageBegin('computeComplexity', TMessageType.CALL, self._seqid)
        args = computeComplexity_args()
        args.problem = problem
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexity failed: unknown result")

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToCNF(expression)
        return self.recv_convertToCNF()

    def send_convertToCNF(self, expression):
        self._oprot.writeMessageBegin('convertToCNF', TMessageType.CALL, self._seqid)
        args = convertToCNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToCNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToCNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToCNF failed: unknown result")

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToDNF(expression)
        return self.recv_convertToDNF()

    def send_convertToDNF(self, expression):
        self._oprot.writeMessageBegin('convertToDNF', TMessageType.CALL, self._seqid)
        args = convertToDNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToDNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToDNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToDNF failed: unknown result")

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        self.send_computeAlgebraicTypicalityWithStringInput(problem, architecture, feature)
        return self.recv_computeAlgebraicTypicalityWithStringInput()

    def send_computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicalityWithStringInput', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.problem = problem
        args.architecture = architecture
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicalityWithStringInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicalityWithStringInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicalityWithStringInput failed: unknown result")

    def getDrivingFeaturesWithGeneralizationBinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesWithGeneralizationBinary(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesWithGeneralizationBinary()

    def send_getDrivingFeaturesWithGeneralizationBinary(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesWithGeneralizationBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesWithGeneralizationBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesWithGeneralizationBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesWithGeneralizationBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesWithGeneralizationBinary failed: unknown result")

    def runInputGeneralizationLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
        """
        self.send_runInputGeneralizationLocalSearchBinary(problem, behavioral, non_behavioral, all_archs, featureExpression)
        return self.recv_runInputGeneralizationLocalSearchBinary()

    def send_runInputGeneralizationLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression):
        self._oprot.writeMessageBegin('runInputGeneralizationLocalSearchBinary', TMessageType.CALL, self._seqid)
        args = runInputGeneralizationLocalSearchBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runInputGeneralizationLocalSearchBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runInputGeneralizationLocalSearchBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runInputGeneralizationLocalSearchBinary failed: unknown result")

    def runFeatureGeneralizationLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
        """
        self.send_runFeatureGeneralizationLocalSearchBinary(problem, behavioral, non_behavioral, all_archs, featureExpression)
        return self.recv_runFeatureGeneralizationLocalSearchBinary()

    def send_runFeatureGeneralizationLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression):
        self._oprot.writeMessageBegin('runFeatureGeneralizationLocalSearchBinary', TMessageType.CALL, self._seqid)
        args = runFeatureGeneralizationLocalSearchBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runFeatureGeneralizationLocalSearchBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runFeatureGeneralizationLocalSearchBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runFeatureGeneralizationLocalSearchBinary failed: unknown result")

    def setAssigningProblemParameters(self, problem, params):
        """
        Parameters:
         - problem
         - params
        """
        self.send_setAssigningProblemParameters(problem, params)
        return self.recv_setAssigningProblemParameters()

    def send_setAssigningProblemParameters(self, problem, params):
        self._oprot.writeMessageBegin('setAssigningProblemParameters', TMessageType.CALL, self._seqid)
        args = setAssigningProblemParameters_args()
        args.problem = problem
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setAssigningProblemParameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setAssigningProblemParameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setAssigningProblemParameters failed: unknown result")

    def getAssigningProblemParameters(self, problem):
        """
        Parameters:
         - problem
        """
        self.send_getAssigningProblemParameters(problem)
        return self.recv_getAssigningProblemParameters()

    def send_getAssigningProblemParameters(self, problem):
        self._oprot.writeMessageBegin('getAssigningProblemParameters', TMessageType.CALL, self._seqid)
        args = getAssigningProblemParameters_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAssigningProblemParameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAssigningProblemParameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAssigningProblemParameters failed: unknown result")

    def setPartitioningAndAssigningProblemParameters(self, problem, params):
        """
        Parameters:
         - problem
         - params
        """
        self.send_setPartitioningAndAssigningProblemParameters(problem, params)
        return self.recv_setPartitioningAndAssigningProblemParameters()

    def send_setPartitioningAndAssigningProblemParameters(self, problem, params):
        self._oprot.writeMessageBegin('setPartitioningAndAssigningProblemParameters', TMessageType.CALL, self._seqid)
        args = setPartitioningAndAssigningProblemParameters_args()
        args.problem = problem
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setPartitioningAndAssigningProblemParameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setPartitioningAndAssigningProblemParameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "setPartitioningAndAssigningProblemParameters failed: unknown result")

    def getPartitioningAndAssigningProblemParameters(self, problem):
        """
        Parameters:
         - problem
        """
        self.send_getPartitioningAndAssigningProblemParameters(problem)
        return self.recv_getPartitioningAndAssigningProblemParameters()

    def send_getPartitioningAndAssigningProblemParameters(self, problem):
        self._oprot.writeMessageBegin('getPartitioningAndAssigningProblemParameters', TMessageType.CALL, self._seqid)
        args = getPartitioningAndAssigningProblemParameters_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPartitioningAndAssigningProblemParameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPartitioningAndAssigningProblemParameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPartitioningAndAssigningProblemParameters failed: unknown result")

    def getTaxonomicScheme(self, problem):
        """
        Parameters:
         - problem
        """
        self.send_getTaxonomicScheme(problem)
        return self.recv_getTaxonomicScheme()

    def send_getTaxonomicScheme(self, problem):
        self._oprot.writeMessageBegin('getTaxonomicScheme', TMessageType.CALL, self._seqid)
        args = getTaxonomicScheme_args()
        args.problem = problem
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTaxonomicScheme(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTaxonomicScheme_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTaxonomicScheme failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["getDrivingFeaturesBinary"] = Processor.process_getDrivingFeaturesBinary
        self._processMap["runAutomatedLocalSearchBinary"] = Processor.process_runAutomatedLocalSearchBinary
        self._processMap["getMarginalDrivingFeaturesBinary"] = Processor.process_getMarginalDrivingFeaturesBinary
        self._processMap["getDrivingFeaturesEpsilonMOEABinary"] = Processor.process_getDrivingFeaturesEpsilonMOEABinary
        self._processMap["getDrivingFeaturesDiscrete"] = Processor.process_getDrivingFeaturesDiscrete
        self._processMap["runAutomatedLocalSearchDiscrete"] = Processor.process_runAutomatedLocalSearchDiscrete
        self._processMap["getMarginalDrivingFeaturesDiscrete"] = Processor.process_getMarginalDrivingFeaturesDiscrete
        self._processMap["getDrivingFeaturesEpsilonMOEADiscrete"] = Processor.process_getDrivingFeaturesEpsilonMOEADiscrete
        self._processMap["computeComplexityOfFeatures"] = Processor.process_computeComplexityOfFeatures
        self._processMap["computeAlgebraicTypicality"] = Processor.process_computeAlgebraicTypicality
        self._processMap["computeComplexity"] = Processor.process_computeComplexity
        self._processMap["convertToCNF"] = Processor.process_convertToCNF
        self._processMap["convertToDNF"] = Processor.process_convertToDNF
        self._processMap["computeAlgebraicTypicalityWithStringInput"] = Processor.process_computeAlgebraicTypicalityWithStringInput
        self._processMap["getDrivingFeaturesWithGeneralizationBinary"] = Processor.process_getDrivingFeaturesWithGeneralizationBinary
        self._processMap["runInputGeneralizationLocalSearchBinary"] = Processor.process_runInputGeneralizationLocalSearchBinary
        self._processMap["runFeatureGeneralizationLocalSearchBinary"] = Processor.process_runFeatureGeneralizationLocalSearchBinary
        self._processMap["setAssigningProblemParameters"] = Processor.process_setAssigningProblemParameters
        self._processMap["getAssigningProblemParameters"] = Processor.process_getAssigningProblemParameters
        self._processMap["setPartitioningAndAssigningProblemParameters"] = Processor.process_setPartitioningAndAssigningProblemParameters
        self._processMap["getPartitioningAndAssigningProblemParameters"] = Processor.process_getPartitioningAndAssigningProblemParameters
        self._processMap["getTaxonomicScheme"] = Processor.process_getTaxonomicScheme

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runAutomatedLocalSearchBinary(self, seqid, iprot, oprot):
        args = runAutomatedLocalSearchBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runAutomatedLocalSearchBinary_result()
        try:
            result.success = self._handler.runAutomatedLocalSearchBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runAutomatedLocalSearchBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEABinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEABinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEABinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runAutomatedLocalSearchDiscrete(self, seqid, iprot, oprot):
        args = runAutomatedLocalSearchDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runAutomatedLocalSearchDiscrete_result()
        try:
            result.success = self._handler.runAutomatedLocalSearchDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runAutomatedLocalSearchDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEADiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEADiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEADiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexityOfFeatures(self, seqid, iprot, oprot):
        args = computeComplexityOfFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexityOfFeatures_result()
        try:
            result.success = self._handler.computeComplexityOfFeatures(args.problem, args.expressions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexityOfFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicality(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicality_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicality_result()
        try:
            result.success = self._handler.computeAlgebraicTypicality(args.problem, args.arch, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicality", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexity(self, seqid, iprot, oprot):
        args = computeComplexity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexity_result()
        try:
            result.success = self._handler.computeComplexity(args.problem, args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToCNF(self, seqid, iprot, oprot):
        args = convertToCNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToCNF_result()
        try:
            result.success = self._handler.convertToCNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToCNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToDNF(self, seqid, iprot, oprot):
        args = convertToDNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToDNF_result()
        try:
            result.success = self._handler.convertToDNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToDNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicalityWithStringInput(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicalityWithStringInput_result()
        try:
            result.success = self._handler.computeAlgebraicTypicalityWithStringInput(args.problem, args.architecture, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicalityWithStringInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesWithGeneralizationBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesWithGeneralizationBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesWithGeneralizationBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesWithGeneralizationBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesWithGeneralizationBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runInputGeneralizationLocalSearchBinary(self, seqid, iprot, oprot):
        args = runInputGeneralizationLocalSearchBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runInputGeneralizationLocalSearchBinary_result()
        try:
            result.success = self._handler.runInputGeneralizationLocalSearchBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runInputGeneralizationLocalSearchBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runFeatureGeneralizationLocalSearchBinary(self, seqid, iprot, oprot):
        args = runFeatureGeneralizationLocalSearchBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runFeatureGeneralizationLocalSearchBinary_result()
        try:
            result.success = self._handler.runFeatureGeneralizationLocalSearchBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runFeatureGeneralizationLocalSearchBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setAssigningProblemParameters(self, seqid, iprot, oprot):
        args = setAssigningProblemParameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setAssigningProblemParameters_result()
        try:
            result.success = self._handler.setAssigningProblemParameters(args.problem, args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setAssigningProblemParameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAssigningProblemParameters(self, seqid, iprot, oprot):
        args = getAssigningProblemParameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAssigningProblemParameters_result()
        try:
            result.success = self._handler.getAssigningProblemParameters(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAssigningProblemParameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setPartitioningAndAssigningProblemParameters(self, seqid, iprot, oprot):
        args = setPartitioningAndAssigningProblemParameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setPartitioningAndAssigningProblemParameters_result()
        try:
            result.success = self._handler.setPartitioningAndAssigningProblemParameters(args.problem, args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setPartitioningAndAssigningProblemParameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPartitioningAndAssigningProblemParameters(self, seqid, iprot, oprot):
        args = getPartitioningAndAssigningProblemParameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPartitioningAndAssigningProblemParameters_result()
        try:
            result.success = self._handler.getPartitioningAndAssigningProblemParameters(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPartitioningAndAssigningProblemParameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTaxonomicScheme(self, seqid, iprot, oprot):
        args = getTaxonomicScheme_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTaxonomicScheme_result()
        try:
            result.success = self._handler.getTaxonomicScheme(args.problem)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTaxonomicScheme", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class getDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype112, _size109) = iprot.readListBegin()
                    for _i113 in range(_size109):
                        _elem114 = iprot.readI32()
                        self.behavioral.append(_elem114)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype118, _size115) = iprot.readListBegin()
                    for _i119 in range(_size115):
                        _elem120 = iprot.readI32()
                        self.non_behavioral.append(_elem120)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = BinaryInputArchitecture()
                        _elem126.read(iprot)
                        self.all_archs.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter127 in self.behavioral:
                oprot.writeI32(iter127)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter128 in self.non_behavioral:
                oprot.writeI32(iter128)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter129 in self.all_archs:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_args)
getDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = Feature()
                        _elem135.read(iprot)
                        self.success.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter136 in self.success:
                iter136.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_result)
getDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class runAutomatedLocalSearchBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = iprot.readI32()
                        self.behavioral.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype146, _size143) = iprot.readListBegin()
                    for _i147 in range(_size143):
                        _elem148 = iprot.readI32()
                        self.non_behavioral.append(_elem148)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = BinaryInputArchitecture()
                        _elem154.read(iprot)
                        self.all_archs.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter155 in self.behavioral:
                oprot.writeI32(iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter156 in self.non_behavioral:
                oprot.writeI32(iter156)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter157 in self.all_archs:
                iter157.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchBinary_args)
runAutomatedLocalSearchBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class runAutomatedLocalSearchBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = Feature()
                        _elem163.read(iprot)
                        self.success.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter164 in self.success:
                iter164.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchBinary_result)
runAutomatedLocalSearchBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype168, _size165) = iprot.readListBegin()
                    for _i169 in range(_size165):
                        _elem170 = iprot.readI32()
                        self.behavioral.append(_elem170)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype174, _size171) = iprot.readListBegin()
                    for _i175 in range(_size171):
                        _elem176 = iprot.readI32()
                        self.non_behavioral.append(_elem176)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype180, _size177) = iprot.readListBegin()
                    for _i181 in range(_size177):
                        _elem182 = BinaryInputArchitecture()
                        _elem182.read(iprot)
                        self.all_archs.append(_elem182)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter183 in self.behavioral:
                oprot.writeI32(iter183)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter184 in self.non_behavioral:
                oprot.writeI32(iter184)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter185 in self.all_archs:
                iter185.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 6)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 7)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 8)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 9)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_args)
getMarginalDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'supp', None, None, ),  # 7
    (8, TType.DOUBLE, 'conf', None, None, ),  # 8
    (9, TType.DOUBLE, 'lift', None, None, ),  # 9
)


class getMarginalDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = Feature()
                        _elem191.read(iprot)
                        self.success.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter192 in self.success:
                iter192.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_result)
getMarginalDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEABinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = iprot.readI32()
                        self.behavioral.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype202, _size199) = iprot.readListBegin()
                    for _i203 in range(_size199):
                        _elem204 = iprot.readI32()
                        self.non_behavioral.append(_elem204)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = BinaryInputArchitecture()
                        _elem210.read(iprot)
                        self.all_archs.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter211 in self.behavioral:
                oprot.writeI32(iter211)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter212 in self.non_behavioral:
                oprot.writeI32(iter212)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter213 in self.all_archs:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_args)
getDrivingFeaturesEpsilonMOEABinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEABinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype217, _size214) = iprot.readListBegin()
                    for _i218 in range(_size214):
                        _elem219 = Feature()
                        _elem219.read(iprot)
                        self.success.append(_elem219)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter220 in self.success:
                iter220.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_result)
getDrivingFeaturesEpsilonMOEABinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype224, _size221) = iprot.readListBegin()
                    for _i225 in range(_size221):
                        _elem226 = iprot.readI32()
                        self.behavioral.append(_elem226)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype230, _size227) = iprot.readListBegin()
                    for _i231 in range(_size227):
                        _elem232 = iprot.readI32()
                        self.non_behavioral.append(_elem232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype236, _size233) = iprot.readListBegin()
                    for _i237 in range(_size233):
                        _elem238 = DiscreteInputArchitecture()
                        _elem238.read(iprot)
                        self.all_archs.append(_elem238)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter239 in self.behavioral:
                oprot.writeI32(iter239)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter240 in self.non_behavioral:
                oprot.writeI32(iter240)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter241 in self.all_archs:
                iter241.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_args)
getDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype245, _size242) = iprot.readListBegin()
                    for _i246 in range(_size242):
                        _elem247 = Feature()
                        _elem247.read(iprot)
                        self.success.append(_elem247)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter248 in self.success:
                iter248.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_result)
getDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class runAutomatedLocalSearchDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype252, _size249) = iprot.readListBegin()
                    for _i253 in range(_size249):
                        _elem254 = iprot.readI32()
                        self.behavioral.append(_elem254)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = iprot.readI32()
                        self.non_behavioral.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = DiscreteInputArchitecture()
                        _elem266.read(iprot)
                        self.all_archs.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter267 in self.behavioral:
                oprot.writeI32(iter267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter268 in self.non_behavioral:
                oprot.writeI32(iter268)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter269 in self.all_archs:
                iter269.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchDiscrete_args)
runAutomatedLocalSearchDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class runAutomatedLocalSearchDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = Feature()
                        _elem275.read(iprot)
                        self.success.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter276 in self.success:
                iter276.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchDiscrete_result)
runAutomatedLocalSearchDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype280, _size277) = iprot.readListBegin()
                    for _i281 in range(_size277):
                        _elem282 = iprot.readI32()
                        self.behavioral.append(_elem282)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readI32()
                        self.non_behavioral.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = DiscreteInputArchitecture()
                        _elem294.read(iprot)
                        self.all_archs.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter295 in self.behavioral:
                oprot.writeI32(iter295)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter296 in self.non_behavioral:
                oprot.writeI32(iter296)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter297 in self.all_archs:
                iter297.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 6)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 7)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 8)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 9)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_args)
getMarginalDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'supp', None, None, ),  # 7
    (8, TType.DOUBLE, 'conf', None, None, ),  # 8
    (9, TType.DOUBLE, 'lift', None, None, ),  # 9
)


class getMarginalDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = Feature()
                        _elem303.read(iprot)
                        self.success.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter304 in self.success:
                iter304.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_result)
getMarginalDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEADiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype308, _size305) = iprot.readListBegin()
                    for _i309 in range(_size305):
                        _elem310 = iprot.readI32()
                        self.behavioral.append(_elem310)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = iprot.readI32()
                        self.non_behavioral.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = DiscreteInputArchitecture()
                        _elem322.read(iprot)
                        self.all_archs.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter323 in self.behavioral:
                oprot.writeI32(iter323)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter324 in self.non_behavioral:
                oprot.writeI32(iter324)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter325 in self.all_archs:
                iter325.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_args)
getDrivingFeaturesEpsilonMOEADiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEADiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = Feature()
                        _elem331.read(iprot)
                        self.success.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter332 in self.success:
                iter332.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_result)
getDrivingFeaturesEpsilonMOEADiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class computeComplexityOfFeatures_args(object):
    """
    Attributes:
     - problem
     - expressions
    """


    def __init__(self, problem=None, expressions=None,):
        self.problem = problem
        self.expressions = expressions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.expressions = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expressions.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expressions is not None:
            oprot.writeFieldBegin('expressions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.expressions))
            for iter339 in self.expressions:
                oprot.writeString(iter339.encode('utf-8') if sys.version_info[0] == 2 else iter339)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_args)
computeComplexityOfFeatures_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'expressions', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class computeComplexityOfFeatures_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype343, _size340) = iprot.readListBegin()
                    for _i344 in range(_size340):
                        _elem345 = iprot.readDouble()
                        self.success.append(_elem345)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter346 in self.success:
                oprot.writeDouble(iter346)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_result)
computeComplexityOfFeatures_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class computeAlgebraicTypicality_args(object):
    """
    Attributes:
     - problem
     - arch
     - feature
    """


    def __init__(self, problem=None, arch=None, feature=None,):
        self.problem = problem
        self.arch = arch
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_args)
computeAlgebraicTypicality_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicality_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = iprot.readI32()
                        self.success.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter353 in self.success:
                oprot.writeI32(iter353)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_result)
computeAlgebraicTypicality_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class computeComplexity_args(object):
    """
    Attributes:
     - problem
     - expression
    """


    def __init__(self, problem=None, expression=None,):
        self.problem = problem
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_args)
computeComplexity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
)


class computeComplexity_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_result)
computeComplexity_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class convertToCNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_args)
convertToCNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToCNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_result)
convertToCNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class convertToDNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_args)
convertToDNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToDNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_result)
convertToDNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class computeAlgebraicTypicalityWithStringInput_args(object):
    """
    Attributes:
     - problem
     - architecture
     - feature
    """


    def __init__(self, problem=None, architecture=None, feature=None,):
        self.problem = problem
        self.architecture = architecture
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.architecture = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.architecture is not None:
            oprot.writeFieldBegin('architecture', TType.STRING, 2)
            oprot.writeString(self.architecture.encode('utf-8') if sys.version_info[0] == 2 else self.architecture)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_args)
computeAlgebraicTypicalityWithStringInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'architecture', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicalityWithStringInput_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = iprot.readI32()
                        self.success.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter360 in self.success:
                oprot.writeI32(iter360)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_result)
computeAlgebraicTypicalityWithStringInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class getDrivingFeaturesWithGeneralizationBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = iprot.readI32()
                        self.behavioral.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype370, _size367) = iprot.readListBegin()
                    for _i371 in range(_size367):
                        _elem372 = iprot.readI32()
                        self.non_behavioral.append(_elem372)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype376, _size373) = iprot.readListBegin()
                    for _i377 in range(_size373):
                        _elem378 = BinaryInputArchitecture()
                        _elem378.read(iprot)
                        self.all_archs.append(_elem378)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesWithGeneralizationBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter379 in self.behavioral:
                oprot.writeI32(iter379)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter380 in self.non_behavioral:
                oprot.writeI32(iter380)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter381 in self.all_archs:
                iter381.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesWithGeneralizationBinary_args)
getDrivingFeaturesWithGeneralizationBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesWithGeneralizationBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = Feature()
                        _elem387.read(iprot)
                        self.success.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesWithGeneralizationBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter388 in self.success:
                iter388.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesWithGeneralizationBinary_result)
getDrivingFeaturesWithGeneralizationBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class runInputGeneralizationLocalSearchBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = iprot.readI32()
                        self.behavioral.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype398, _size395) = iprot.readListBegin()
                    for _i399 in range(_size395):
                        _elem400 = iprot.readI32()
                        self.non_behavioral.append(_elem400)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype404, _size401) = iprot.readListBegin()
                    for _i405 in range(_size401):
                        _elem406 = BinaryInputArchitecture()
                        _elem406.read(iprot)
                        self.all_archs.append(_elem406)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runInputGeneralizationLocalSearchBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter407 in self.behavioral:
                oprot.writeI32(iter407)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter408 in self.non_behavioral:
                oprot.writeI32(iter408)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter409 in self.all_archs:
                iter409.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runInputGeneralizationLocalSearchBinary_args)
runInputGeneralizationLocalSearchBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
)


class runInputGeneralizationLocalSearchBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype413, _size410) = iprot.readListBegin()
                    for _i414 in range(_size410):
                        _elem415 = Feature()
                        _elem415.read(iprot)
                        self.success.append(_elem415)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runInputGeneralizationLocalSearchBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter416 in self.success:
                iter416.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runInputGeneralizationLocalSearchBinary_result)
runInputGeneralizationLocalSearchBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class runFeatureGeneralizationLocalSearchBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = iprot.readI32()
                        self.behavioral.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype426, _size423) = iprot.readListBegin()
                    for _i427 in range(_size423):
                        _elem428 = iprot.readI32()
                        self.non_behavioral.append(_elem428)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype432, _size429) = iprot.readListBegin()
                    for _i433 in range(_size429):
                        _elem434 = BinaryInputArchitecture()
                        _elem434.read(iprot)
                        self.all_archs.append(_elem434)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runFeatureGeneralizationLocalSearchBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter435 in self.behavioral:
                oprot.writeI32(iter435)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter436 in self.non_behavioral:
                oprot.writeI32(iter436)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter437 in self.all_archs:
                iter437.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runFeatureGeneralizationLocalSearchBinary_args)
runFeatureGeneralizationLocalSearchBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
)


class runFeatureGeneralizationLocalSearchBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype441, _size438) = iprot.readListBegin()
                    for _i442 in range(_size438):
                        _elem443 = Feature()
                        _elem443.read(iprot)
                        self.success.append(_elem443)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runFeatureGeneralizationLocalSearchBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter444 in self.success:
                iter444.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runFeatureGeneralizationLocalSearchBinary_result)
runFeatureGeneralizationLocalSearchBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class setAssigningProblemParameters_args(object):
    """
    Attributes:
     - problem
     - params
    """


    def __init__(self, problem=None, params=None,):
        self.problem = problem
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = AssigningProblemParameters()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemParameters_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemParameters_args)
setAssigningProblemParameters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'params', [AssigningProblemParameters, None], None, ),  # 2
)


class setAssigningProblemParameters_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setAssigningProblemParameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setAssigningProblemParameters_result)
setAssigningProblemParameters_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getAssigningProblemParameters_args(object):
    """
    Attributes:
     - problem
    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemParameters_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemParameters_args)
getAssigningProblemParameters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getAssigningProblemParameters_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AssigningProblemParameters()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAssigningProblemParameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAssigningProblemParameters_result)
getAssigningProblemParameters_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [AssigningProblemParameters, None], None, ),  # 0
)


class setPartitioningAndAssigningProblemParameters_args(object):
    """
    Attributes:
     - problem
     - params
    """


    def __init__(self, problem=None, params=None,):
        self.problem = problem
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = PartitioningAndAssigningProblemParameters()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setPartitioningAndAssigningProblemParameters_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setPartitioningAndAssigningProblemParameters_args)
setPartitioningAndAssigningProblemParameters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'params', [PartitioningAndAssigningProblemParameters, None], None, ),  # 2
)


class setPartitioningAndAssigningProblemParameters_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setPartitioningAndAssigningProblemParameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setPartitioningAndAssigningProblemParameters_result)
setPartitioningAndAssigningProblemParameters_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getPartitioningAndAssigningProblemParameters_args(object):
    """
    Attributes:
     - problem
    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPartitioningAndAssigningProblemParameters_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPartitioningAndAssigningProblemParameters_args)
getPartitioningAndAssigningProblemParameters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getPartitioningAndAssigningProblemParameters_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitioningAndAssigningProblemParameters()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPartitioningAndAssigningProblemParameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPartitioningAndAssigningProblemParameters_result)
getPartitioningAndAssigningProblemParameters_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PartitioningAndAssigningProblemParameters, None], None, ),  # 0
)


class getTaxonomicScheme_args(object):
    """
    Attributes:
     - problem
    """


    def __init__(self, problem=None,):
        self.problem = problem

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTaxonomicScheme_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTaxonomicScheme_args)
getTaxonomicScheme_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
)


class getTaxonomicScheme_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TaxonomicScheme()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTaxonomicScheme_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTaxonomicScheme_result)
getTaxonomicScheme_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TaxonomicScheme, None], None, ),  # 0
)
fix_spec(all_structs)
del all_structs

