#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        pass

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def runAutomatedLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def runAutomatedLocalSearchDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        pass

    def getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        pass

    def getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        pass

    def computeComplexityOfFeatures(self, problem, expressions):
        """
        Parameters:
         - problem
         - expressions
        """
        pass

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        pass

    def computeComplexity(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        pass

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        pass

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesBinary()

    def send_getDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesBinary failed: unknown result")

    def runAutomatedLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_runAutomatedLocalSearchBinary(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_runAutomatedLocalSearchBinary()

    def send_runAutomatedLocalSearchBinary(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('runAutomatedLocalSearchBinary', TMessageType.CALL, self._seqid)
        args = runAutomatedLocalSearchBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runAutomatedLocalSearchBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runAutomatedLocalSearchBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runAutomatedLocalSearchBinary failed: unknown result")

    def getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        self.send_getMarginalDrivingFeaturesBinary(problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift)
        return self.recv_getMarginalDrivingFeaturesBinary()

    def send_getMarginalDrivingFeaturesBinary(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesBinary', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesBinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesBinary failed: unknown result")

    def getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEABinary(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEABinary()

    def send_getDrivingFeaturesEpsilonMOEABinary(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEABinary', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEABinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEABinary failed: unknown result")

    def getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_getDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_getDrivingFeaturesDiscrete()

    def send_getDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('getDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesDiscrete failed: unknown result")

    def runAutomatedLocalSearchDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - supp
         - conf
         - lift
        """
        self.send_runAutomatedLocalSearchDiscrete(problem, behavioral, non_behavioral, all_archs, supp, conf, lift)
        return self.recv_runAutomatedLocalSearchDiscrete()

    def send_runAutomatedLocalSearchDiscrete(self, problem, behavioral, non_behavioral, all_archs, supp, conf, lift):
        self._oprot.writeMessageBegin('runAutomatedLocalSearchDiscrete', TMessageType.CALL, self._seqid)
        args = runAutomatedLocalSearchDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runAutomatedLocalSearchDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runAutomatedLocalSearchDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runAutomatedLocalSearchDiscrete failed: unknown result")

    def getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
         - featureExpression
         - logical_connective
         - supp
         - conf
         - lift
        """
        self.send_getMarginalDrivingFeaturesDiscrete(problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift)
        return self.recv_getMarginalDrivingFeaturesDiscrete()

    def send_getMarginalDrivingFeaturesDiscrete(self, problem, behavioral, non_behavioral, all_archs, featureExpression, logical_connective, supp, conf, lift):
        self._oprot.writeMessageBegin('getMarginalDrivingFeaturesDiscrete', TMessageType.CALL, self._seqid)
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.featureExpression = featureExpression
        args.logical_connective = logical_connective
        args.supp = supp
        args.conf = conf
        args.lift = lift
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMarginalDrivingFeaturesDiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMarginalDrivingFeaturesDiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMarginalDrivingFeaturesDiscrete failed: unknown result")

    def getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        """
        Parameters:
         - problem
         - behavioral
         - non_behavioral
         - all_archs
        """
        self.send_getDrivingFeaturesEpsilonMOEADiscrete(problem, behavioral, non_behavioral, all_archs)
        return self.recv_getDrivingFeaturesEpsilonMOEADiscrete()

    def send_getDrivingFeaturesEpsilonMOEADiscrete(self, problem, behavioral, non_behavioral, all_archs):
        self._oprot.writeMessageBegin('getDrivingFeaturesEpsilonMOEADiscrete', TMessageType.CALL, self._seqid)
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.problem = problem
        args.behavioral = behavioral
        args.non_behavioral = non_behavioral
        args.all_archs = all_archs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDrivingFeaturesEpsilonMOEADiscrete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDrivingFeaturesEpsilonMOEADiscrete failed: unknown result")

    def computeComplexityOfFeatures(self, problem, expressions):
        """
        Parameters:
         - problem
         - expressions
        """
        self.send_computeComplexityOfFeatures(problem, expressions)
        return self.recv_computeComplexityOfFeatures()

    def send_computeComplexityOfFeatures(self, problem, expressions):
        self._oprot.writeMessageBegin('computeComplexityOfFeatures', TMessageType.CALL, self._seqid)
        args = computeComplexityOfFeatures_args()
        args.problem = problem
        args.expressions = expressions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexityOfFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexityOfFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexityOfFeatures failed: unknown result")

    def computeAlgebraicTypicality(self, problem, arch, feature):
        """
        Parameters:
         - problem
         - arch
         - feature
        """
        self.send_computeAlgebraicTypicality(problem, arch, feature)
        return self.recv_computeAlgebraicTypicality()

    def send_computeAlgebraicTypicality(self, problem, arch, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicality', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicality_args()
        args.problem = problem
        args.arch = arch
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicality(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicality_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicality failed: unknown result")

    def computeComplexity(self, problem, expression):
        """
        Parameters:
         - problem
         - expression
        """
        self.send_computeComplexity(problem, expression)
        return self.recv_computeComplexity()

    def send_computeComplexity(self, problem, expression):
        self._oprot.writeMessageBegin('computeComplexity', TMessageType.CALL, self._seqid)
        args = computeComplexity_args()
        args.problem = problem
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeComplexity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeComplexity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeComplexity failed: unknown result")

    def convertToCNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToCNF(expression)
        return self.recv_convertToCNF()

    def send_convertToCNF(self, expression):
        self._oprot.writeMessageBegin('convertToCNF', TMessageType.CALL, self._seqid)
        args = convertToCNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToCNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToCNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToCNF failed: unknown result")

    def convertToDNF(self, expression):
        """
        Parameters:
         - expression
        """
        self.send_convertToDNF(expression)
        return self.recv_convertToDNF()

    def send_convertToDNF(self, expression):
        self._oprot.writeMessageBegin('convertToDNF', TMessageType.CALL, self._seqid)
        args = convertToDNF_args()
        args.expression = expression
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_convertToDNF(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = convertToDNF_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "convertToDNF failed: unknown result")

    def computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        """
        Parameters:
         - problem
         - architecture
         - feature
        """
        self.send_computeAlgebraicTypicalityWithStringInput(problem, architecture, feature)
        return self.recv_computeAlgebraicTypicalityWithStringInput()

    def send_computeAlgebraicTypicalityWithStringInput(self, problem, architecture, feature):
        self._oprot.writeMessageBegin('computeAlgebraicTypicalityWithStringInput', TMessageType.CALL, self._seqid)
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.problem = problem
        args.architecture = architecture
        args.feature = feature
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeAlgebraicTypicalityWithStringInput(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeAlgebraicTypicalityWithStringInput_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeAlgebraicTypicalityWithStringInput failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["getDrivingFeaturesBinary"] = Processor.process_getDrivingFeaturesBinary
        self._processMap["runAutomatedLocalSearchBinary"] = Processor.process_runAutomatedLocalSearchBinary
        self._processMap["getMarginalDrivingFeaturesBinary"] = Processor.process_getMarginalDrivingFeaturesBinary
        self._processMap["getDrivingFeaturesEpsilonMOEABinary"] = Processor.process_getDrivingFeaturesEpsilonMOEABinary
        self._processMap["getDrivingFeaturesDiscrete"] = Processor.process_getDrivingFeaturesDiscrete
        self._processMap["runAutomatedLocalSearchDiscrete"] = Processor.process_runAutomatedLocalSearchDiscrete
        self._processMap["getMarginalDrivingFeaturesDiscrete"] = Processor.process_getMarginalDrivingFeaturesDiscrete
        self._processMap["getDrivingFeaturesEpsilonMOEADiscrete"] = Processor.process_getDrivingFeaturesEpsilonMOEADiscrete
        self._processMap["computeComplexityOfFeatures"] = Processor.process_computeComplexityOfFeatures
        self._processMap["computeAlgebraicTypicality"] = Processor.process_computeAlgebraicTypicality
        self._processMap["computeComplexity"] = Processor.process_computeComplexity
        self._processMap["convertToCNF"] = Processor.process_convertToCNF
        self._processMap["convertToDNF"] = Processor.process_convertToDNF
        self._processMap["computeAlgebraicTypicalityWithStringInput"] = Processor.process_computeAlgebraicTypicalityWithStringInput

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runAutomatedLocalSearchBinary(self, seqid, iprot, oprot):
        args = runAutomatedLocalSearchBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runAutomatedLocalSearchBinary_result()
        try:
            result.success = self._handler.runAutomatedLocalSearchBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runAutomatedLocalSearchBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesBinary(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesBinary_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesBinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEABinary(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEABinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEABinary_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEABinary(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEABinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runAutomatedLocalSearchDiscrete(self, seqid, iprot, oprot):
        args = runAutomatedLocalSearchDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runAutomatedLocalSearchDiscrete_result()
        try:
            result.success = self._handler.runAutomatedLocalSearchDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runAutomatedLocalSearchDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMarginalDrivingFeaturesDiscrete(self, seqid, iprot, oprot):
        args = getMarginalDrivingFeaturesDiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMarginalDrivingFeaturesDiscrete_result()
        try:
            result.success = self._handler.getMarginalDrivingFeaturesDiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs, args.featureExpression, args.logical_connective, args.supp, args.conf, args.lift)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMarginalDrivingFeaturesDiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDrivingFeaturesEpsilonMOEADiscrete(self, seqid, iprot, oprot):
        args = getDrivingFeaturesEpsilonMOEADiscrete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDrivingFeaturesEpsilonMOEADiscrete_result()
        try:
            result.success = self._handler.getDrivingFeaturesEpsilonMOEADiscrete(args.problem, args.behavioral, args.non_behavioral, args.all_archs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDrivingFeaturesEpsilonMOEADiscrete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexityOfFeatures(self, seqid, iprot, oprot):
        args = computeComplexityOfFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexityOfFeatures_result()
        try:
            result.success = self._handler.computeComplexityOfFeatures(args.problem, args.expressions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexityOfFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicality(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicality_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicality_result()
        try:
            result.success = self._handler.computeAlgebraicTypicality(args.problem, args.arch, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicality", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeComplexity(self, seqid, iprot, oprot):
        args = computeComplexity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeComplexity_result()
        try:
            result.success = self._handler.computeComplexity(args.problem, args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeComplexity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToCNF(self, seqid, iprot, oprot):
        args = convertToCNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToCNF_result()
        try:
            result.success = self._handler.convertToCNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToCNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_convertToDNF(self, seqid, iprot, oprot):
        args = convertToDNF_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = convertToDNF_result()
        try:
            result.success = self._handler.convertToDNF(args.expression)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("convertToDNF", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeAlgebraicTypicalityWithStringInput(self, seqid, iprot, oprot):
        args = computeAlgebraicTypicalityWithStringInput_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeAlgebraicTypicalityWithStringInput_result()
        try:
            result.success = self._handler.computeAlgebraicTypicalityWithStringInput(args.problem, args.architecture, args.feature)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeAlgebraicTypicalityWithStringInput", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class getDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readI32()
                        self.behavioral.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readI32()
                        self.non_behavioral.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = BinaryInputArchitecture()
                        _elem66.read(iprot)
                        self.all_archs.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter67 in self.behavioral:
                oprot.writeI32(iter67)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter68 in self.non_behavioral:
                oprot.writeI32(iter68)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter69 in self.all_archs:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_args)
getDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = Feature()
                        _elem75.read(iprot)
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter76 in self.success:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesBinary_result)
getDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class runAutomatedLocalSearchBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readI32()
                        self.behavioral.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readI32()
                        self.non_behavioral.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = BinaryInputArchitecture()
                        _elem94.read(iprot)
                        self.all_archs.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter95 in self.behavioral:
                oprot.writeI32(iter95)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter96 in self.non_behavioral:
                oprot.writeI32(iter96)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter97 in self.all_archs:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchBinary_args)
runAutomatedLocalSearchBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class runAutomatedLocalSearchBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = Feature()
                        _elem103.read(iprot)
                        self.success.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter104 in self.success:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchBinary_result)
runAutomatedLocalSearchBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesBinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = iprot.readI32()
                        self.behavioral.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readI32()
                        self.non_behavioral.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = BinaryInputArchitecture()
                        _elem122.read(iprot)
                        self.all_archs.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter123 in self.behavioral:
                oprot.writeI32(iter123)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter124 in self.non_behavioral:
                oprot.writeI32(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter125 in self.all_archs:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 6)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 7)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 8)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 9)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_args)
getMarginalDrivingFeaturesBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'supp', None, None, ),  # 7
    (8, TType.DOUBLE, 'conf', None, None, ),  # 8
    (9, TType.DOUBLE, 'lift', None, None, ),  # 9
)


class getMarginalDrivingFeaturesBinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = Feature()
                        _elem131.read(iprot)
                        self.success.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter132 in self.success:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesBinary_result)
getMarginalDrivingFeaturesBinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEABinary_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = iprot.readI32()
                        self.behavioral.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = iprot.readI32()
                        self.non_behavioral.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = BinaryInputArchitecture()
                        _elem150.read(iprot)
                        self.all_archs.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter151 in self.behavioral:
                oprot.writeI32(iter151)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter152 in self.non_behavioral:
                oprot.writeI32(iter152)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter153 in self.all_archs:
                iter153.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_args)
getDrivingFeaturesEpsilonMOEABinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [BinaryInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEABinary_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype157, _size154) = iprot.readListBegin()
                    for _i158 in range(_size154):
                        _elem159 = Feature()
                        _elem159.read(iprot)
                        self.success.append(_elem159)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEABinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter160 in self.success:
                iter160.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEABinary_result)
getDrivingFeaturesEpsilonMOEABinary_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = iprot.readI32()
                        self.behavioral.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = iprot.readI32()
                        self.non_behavioral.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = DiscreteInputArchitecture()
                        _elem178.read(iprot)
                        self.all_archs.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter179 in self.behavioral:
                oprot.writeI32(iter179)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter180 in self.non_behavioral:
                oprot.writeI32(iter180)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter181 in self.all_archs:
                iter181.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_args)
getDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class getDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = Feature()
                        _elem187.read(iprot)
                        self.success.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter188 in self.success:
                iter188.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesDiscrete_result)
getDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class runAutomatedLocalSearchDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype192, _size189) = iprot.readListBegin()
                    for _i193 in range(_size189):
                        _elem194 = iprot.readI32()
                        self.behavioral.append(_elem194)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = iprot.readI32()
                        self.non_behavioral.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = DiscreteInputArchitecture()
                        _elem206.read(iprot)
                        self.all_archs.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter207 in self.behavioral:
                oprot.writeI32(iter207)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter208 in self.non_behavioral:
                oprot.writeI32(iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter209 in self.all_archs:
                iter209.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 5)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 6)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 7)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchDiscrete_args)
runAutomatedLocalSearchDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'supp', None, None, ),  # 5
    (6, TType.DOUBLE, 'conf', None, None, ),  # 6
    (7, TType.DOUBLE, 'lift', None, None, ),  # 7
)


class runAutomatedLocalSearchDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = Feature()
                        _elem215.read(iprot)
                        self.success.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runAutomatedLocalSearchDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter216 in self.success:
                iter216.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runAutomatedLocalSearchDiscrete_result)
runAutomatedLocalSearchDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getMarginalDrivingFeaturesDiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
     - featureExpression
     - logical_connective
     - supp
     - conf
     - lift
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None, featureExpression=None, logical_connective=None, supp=None, conf=None, lift=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs
        self.featureExpression = featureExpression
        self.logical_connective = logical_connective
        self.supp = supp
        self.conf = conf
        self.lift = lift

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = iprot.readI32()
                        self.behavioral.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = iprot.readI32()
                        self.non_behavioral.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype232, _size229) = iprot.readListBegin()
                    for _i233 in range(_size229):
                        _elem234 = DiscreteInputArchitecture()
                        _elem234.read(iprot)
                        self.all_archs.append(_elem234)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.featureExpression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.logical_connective = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.supp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.conf = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.lift = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter235 in self.behavioral:
                oprot.writeI32(iter235)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter236 in self.non_behavioral:
                oprot.writeI32(iter236)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter237 in self.all_archs:
                iter237.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.featureExpression is not None:
            oprot.writeFieldBegin('featureExpression', TType.STRING, 5)
            oprot.writeString(self.featureExpression.encode('utf-8') if sys.version_info[0] == 2 else self.featureExpression)
            oprot.writeFieldEnd()
        if self.logical_connective is not None:
            oprot.writeFieldBegin('logical_connective', TType.STRING, 6)
            oprot.writeString(self.logical_connective.encode('utf-8') if sys.version_info[0] == 2 else self.logical_connective)
            oprot.writeFieldEnd()
        if self.supp is not None:
            oprot.writeFieldBegin('supp', TType.DOUBLE, 7)
            oprot.writeDouble(self.supp)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.DOUBLE, 8)
            oprot.writeDouble(self.conf)
            oprot.writeFieldEnd()
        if self.lift is not None:
            oprot.writeFieldBegin('lift', TType.DOUBLE, 9)
            oprot.writeDouble(self.lift)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_args)
getMarginalDrivingFeaturesDiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
    (5, TType.STRING, 'featureExpression', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'logical_connective', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'supp', None, None, ),  # 7
    (8, TType.DOUBLE, 'conf', None, None, ),  # 8
    (9, TType.DOUBLE, 'lift', None, None, ),  # 9
)


class getMarginalDrivingFeaturesDiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = Feature()
                        _elem243.read(iprot)
                        self.success.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMarginalDrivingFeaturesDiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter244 in self.success:
                iter244.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMarginalDrivingFeaturesDiscrete_result)
getMarginalDrivingFeaturesDiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class getDrivingFeaturesEpsilonMOEADiscrete_args(object):
    """
    Attributes:
     - problem
     - behavioral
     - non_behavioral
     - all_archs
    """


    def __init__(self, problem=None, behavioral=None, non_behavioral=None, all_archs=None,):
        self.problem = problem
        self.behavioral = behavioral
        self.non_behavioral = non_behavioral
        self.all_archs = all_archs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.behavioral = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readI32()
                        self.behavioral.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.non_behavioral = []
                    (_etype254, _size251) = iprot.readListBegin()
                    for _i255 in range(_size251):
                        _elem256 = iprot.readI32()
                        self.non_behavioral.append(_elem256)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.all_archs = []
                    (_etype260, _size257) = iprot.readListBegin()
                    for _i261 in range(_size257):
                        _elem262 = DiscreteInputArchitecture()
                        _elem262.read(iprot)
                        self.all_archs.append(_elem262)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.behavioral is not None:
            oprot.writeFieldBegin('behavioral', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.behavioral))
            for iter263 in self.behavioral:
                oprot.writeI32(iter263)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.non_behavioral is not None:
            oprot.writeFieldBegin('non_behavioral', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.non_behavioral))
            for iter264 in self.non_behavioral:
                oprot.writeI32(iter264)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.all_archs is not None:
            oprot.writeFieldBegin('all_archs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.all_archs))
            for iter265 in self.all_archs:
                iter265.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_args)
getDrivingFeaturesEpsilonMOEADiscrete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'behavioral', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'non_behavioral', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'all_archs', (TType.STRUCT, [DiscreteInputArchitecture, None], False), None, ),  # 4
)


class getDrivingFeaturesEpsilonMOEADiscrete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype269, _size266) = iprot.readListBegin()
                    for _i270 in range(_size266):
                        _elem271 = Feature()
                        _elem271.read(iprot)
                        self.success.append(_elem271)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDrivingFeaturesEpsilonMOEADiscrete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter272 in self.success:
                iter272.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDrivingFeaturesEpsilonMOEADiscrete_result)
getDrivingFeaturesEpsilonMOEADiscrete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [Feature, None], False), None, ),  # 0
)


class computeComplexityOfFeatures_args(object):
    """
    Attributes:
     - problem
     - expressions
    """


    def __init__(self, problem=None, expressions=None,):
        self.problem = problem
        self.expressions = expressions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.expressions = []
                    (_etype276, _size273) = iprot.readListBegin()
                    for _i277 in range(_size273):
                        _elem278 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.expressions.append(_elem278)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expressions is not None:
            oprot.writeFieldBegin('expressions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.expressions))
            for iter279 in self.expressions:
                oprot.writeString(iter279.encode('utf-8') if sys.version_info[0] == 2 else iter279)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_args)
computeComplexityOfFeatures_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'expressions', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class computeComplexityOfFeatures_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype283, _size280) = iprot.readListBegin()
                    for _i284 in range(_size280):
                        _elem285 = iprot.readDouble()
                        self.success.append(_elem285)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexityOfFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter286 in self.success:
                oprot.writeDouble(iter286)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexityOfFeatures_result)
computeComplexityOfFeatures_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class computeAlgebraicTypicality_args(object):
    """
    Attributes:
     - problem
     - arch
     - feature
    """


    def __init__(self, problem=None, arch=None, feature=None,):
        self.problem = problem
        self.arch = arch
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.arch = BinaryInputArchitecture()
                    self.arch.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.arch is not None:
            oprot.writeFieldBegin('arch', TType.STRUCT, 2)
            self.arch.write(oprot)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_args)
computeAlgebraicTypicality_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'arch', [BinaryInputArchitecture, None], None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicality_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readI32()
                        self.success.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicality_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter293 in self.success:
                oprot.writeI32(iter293)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicality_result)
computeAlgebraicTypicality_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class computeComplexity_args(object):
    """
    Attributes:
     - problem
     - expression
    """


    def __init__(self, problem=None, expression=None,):
        self.problem = problem
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_args)
computeComplexity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
)


class computeComplexity_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeComplexity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeComplexity_result)
computeComplexity_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class convertToCNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_args)
convertToCNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToCNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToCNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToCNF_result)
convertToCNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class convertToDNF_args(object):
    """
    Attributes:
     - expression
    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_args')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_args)
convertToDNF_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)


class convertToDNF_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('convertToDNF_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(convertToDNF_result)
convertToDNF_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class computeAlgebraicTypicalityWithStringInput_args(object):
    """
    Attributes:
     - problem
     - architecture
     - feature
    """


    def __init__(self, problem=None, architecture=None, feature=None,):
        self.problem = problem
        self.architecture = architecture
        self.feature = feature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.problem = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.architecture = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.feature = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_args')
        if self.problem is not None:
            oprot.writeFieldBegin('problem', TType.STRING, 1)
            oprot.writeString(self.problem.encode('utf-8') if sys.version_info[0] == 2 else self.problem)
            oprot.writeFieldEnd()
        if self.architecture is not None:
            oprot.writeFieldBegin('architecture', TType.STRING, 2)
            oprot.writeString(self.architecture.encode('utf-8') if sys.version_info[0] == 2 else self.architecture)
            oprot.writeFieldEnd()
        if self.feature is not None:
            oprot.writeFieldBegin('feature', TType.STRING, 3)
            oprot.writeString(self.feature.encode('utf-8') if sys.version_info[0] == 2 else self.feature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_args)
computeAlgebraicTypicalityWithStringInput_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'problem', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'architecture', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'feature', 'UTF8', None, ),  # 3
)


class computeAlgebraicTypicalityWithStringInput_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype297, _size294) = iprot.readListBegin()
                    for _i298 in range(_size294):
                        _elem299 = iprot.readI32()
                        self.success.append(_elem299)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('computeAlgebraicTypicalityWithStringInput_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter300 in self.success:
                oprot.writeI32(iter300)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(computeAlgebraicTypicalityWithStringInput_result)
computeAlgebraicTypicalityWithStringInput_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs

